#! /usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/zod-state.ts
var import_zod2 = require("zod");

// src/utils.ts
var import_os = require("os");
var import_zod = require("zod");
var import_picocolors = __toESM(require("picocolors"));
var import_child_process = require("child_process");
var p = __toESM(require("@clack/prompts"));
var import_fs = __toESM(require("fs"));
var import_zod_validation_error = require("zod-validation-error");
var CONFIG_FILE_NAME = ".better-commits.json";
var SPACE_TO_SELECT = `${import_picocolors.default.dim("(<space> to select)")}`;
var A_FOR_ALL = `${import_picocolors.default.dim(
  "(<space> to select, <a> to select all)"
)}`;
var OPTIONAL_PROMPT = `${import_picocolors.default.dim("(optional)")}`;
var CACHE_PROMPT = `${import_picocolors.default.dim("(value will be saved)")}`;
var REGEX_SLASH_TAG = new RegExp(/\/(\w+-\d+)/);
var REGEX_START_TAG = new RegExp(/^(\w+-\d+)/);
var REGEX_START_UND = new RegExp(/^([A-Z]+-[\[a-zA-Z\]\d]+)_/);
var REGEX_SLASH_UND = new RegExp(/\/([A-Z]+-[\[a-zA-Z\]\d]+)_/);
var REGEX_SLASH_NUM = new RegExp(/\/(\d+)/);
var REGEX_START_NUM = new RegExp(/^(\d+)/);
var DEFAULT_TYPE_OPTIONS = [
  { value: "feat", label: "feat", hint: "A new feature", emoji: "\u2728", trailer: "Changelog: feature" },
  { value: "fix", label: "fix", hint: "A bug fix", emoji: "\u{1F41B}", trailer: "Changelog: fix" },
  {
    value: "docs",
    label: "docs",
    hint: "Documentation only changes",
    emoji: "\u{1F4DA}",
    trailer: "Changelog: documentation"
  },
  {
    value: "refactor",
    label: "refactor",
    hint: "A code change that neither fixes a bug nor adds a feature",
    emoji: "\u{1F528}",
    trailer: "Changelog: refactor"
  },
  {
    value: "perf",
    label: "perf",
    hint: "A code change that improves performance",
    emoji: "\u{1F680}",
    trailer: "Changelog: performance"
  },
  {
    value: "test",
    label: "test",
    hint: "Adding missing tests or correcting existing tests",
    emoji: "\u{1F6A8}",
    trailer: "Changelog: test"
  },
  {
    value: "build",
    label: "build",
    hint: "Changes that affect the build system or external dependencies",
    emoji: "\u{1F6A7}",
    trailer: "Changelog: build"
  },
  {
    value: "ci",
    label: "ci",
    hint: "Changes to our CI configuration files and scripts",
    emoji: "\u{1F916}",
    trailer: "Changelog: ci"
  },
  {
    value: "chore",
    label: "chore",
    hint: "Other changes that do not modify src or test files",
    emoji: "\u{1F9F9}",
    trailer: "Changelog: chore"
  },
  { value: "", label: "none" }
];
var DEFAULT_SCOPE_OPTIONS = [
  { value: "app", label: "app" },
  { value: "shared", label: "shared" },
  { value: "server", label: "server" },
  { value: "tools", label: "tools" },
  { value: "", label: "none" }
];
var CUSTOM_SCOPE_KEY = "custom";
var Z_FOOTER_OPTIONS = import_zod.z.enum([
  "closes",
  "trailer",
  "breaking-change",
  "deprecated",
  "custom"
]);
var Z_BRANCH_FIELDS = import_zod.z.enum(["user", "version", "type", "ticket", "description"]);
var Z_BRANCH_CONFIG_FIELDS = import_zod.z.enum([
  "branch_user",
  "branch_version",
  "branch_type",
  "branch_ticket",
  "branch_description"
]);
var BRANCH_ORDER_DEFAULTS = ["user", "version", "type", "ticket", "description"];
var Z_BRANCH_ACTIONS = import_zod.z.enum(["branch", "worktree"]);
var FOOTER_OPTION_VALUES = [
  "closes",
  "trailer",
  "breaking-change",
  "deprecated",
  "custom"
];
var BRANCH_ACTION_OPTIONS = [
  { value: "branch", label: "Branch" },
  { value: "worktree", label: "Worktree" }
];
function load_setup(cli_name = " better-commits ") {
  console.clear();
  p.intro(`${import_picocolors.default.bgCyan(import_picocolors.default.black(cli_name))}`);
  const root = get_git_root();
  const root_path = `${root}/${CONFIG_FILE_NAME}`;
  if (import_fs.default.existsSync(root_path)) {
    p.log.step("Found repository config");
    return read_config_from_path(root_path);
  }
  const home_path = get_default_config_path();
  if (import_fs.default.existsSync(home_path)) {
    p.log.step("Found global config");
    return read_config_from_path(home_path);
  }
  const default_config = Config.parse({});
  p.log.step(
    "Config not found. Generating default .better-commit.json at $HOME"
  );
  import_fs.default.writeFileSync(home_path, JSON.stringify(default_config, null, 4));
  return default_config;
}
function read_config_from_path(config_path) {
  let res = null;
  try {
    res = JSON.parse(import_fs.default.readFileSync(config_path, "utf8"));
  } catch (err) {
    p.log.error("Invalid JSON file. Exiting.\n" + err);
    process.exit(0);
  }
  return validate_config(res);
}
function validate_config(config) {
  try {
    return Config.parse(config);
  } catch (err) {
    console.log((0, import_zod_validation_error.fromZodError)(err).message);
    process.exit(0);
  }
}
function get_git_root() {
  let path = ".";
  try {
    path = (0, import_child_process.execSync)("git rev-parse --show-toplevel").toString().trim();
  } catch (err) {
    p.log.warn(
      "Could not find git root. If in a --bare repository, ignore this warning."
    );
  }
  return path;
}
function get_default_config_path() {
  return (0, import_os.homedir)() + "/" + CONFIG_FILE_NAME;
}

// src/zod-state.ts
var Config = import_zod2.z.object({
  check_status: import_zod2.z.boolean().default(true),
  commit_type: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    initial_value: import_zod2.z.string().default("feat"),
    infer_type_from_branch: import_zod2.z.boolean().default(true),
    append_emoji_to_label: import_zod2.z.boolean().default(false),
    append_emoji_to_commit: import_zod2.z.boolean().default(false),
    options: import_zod2.z.array(
      import_zod2.z.object({
        value: import_zod2.z.string(),
        label: import_zod2.z.string().optional(),
        hint: import_zod2.z.string().optional(),
        emoji: import_zod2.z.string().emoji().optional(),
        trailer: import_zod2.z.string().optional()
      })
    ).default(DEFAULT_TYPE_OPTIONS)
  }).default({}).transform((val) => {
    const options = val.options.map((v) => ({
      ...v,
      label: v.emoji && val.append_emoji_to_label ? `${v.emoji} ${v.label}` : v.label
    }));
    return { ...val, options };
  }).refine(
    (val) => val.options.map((v) => v.value).includes(val.initial_value),
    (val) => ({
      message: `Type: initial_value "${val.initial_value}" must exist in options`
    })
  ),
  commit_scope: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    custom_scope: import_zod2.z.boolean().default(false),
    initial_value: import_zod2.z.string().default("app"),
    options: import_zod2.z.array(
      import_zod2.z.object({
        value: import_zod2.z.string(),
        label: import_zod2.z.string().optional(),
        hint: import_zod2.z.string().optional()
      })
    ).default(DEFAULT_SCOPE_OPTIONS)
  }).default({}).transform((val) => {
    const options = val.options.map((v) => v.value);
    if (val.custom_scope && !options.includes(CUSTOM_SCOPE_KEY)) {
      return {
        ...val,
        options: [
          ...val.options,
          {
            label: CUSTOM_SCOPE_KEY,
            value: CUSTOM_SCOPE_KEY,
            hint: "Write a custom scope"
          }
        ]
      };
    }
    return val;
  }).refine(
    (val) => {
      const options = val.options.map((v) => v.value);
      return options.includes(val.initial_value);
    },
    (val) => ({
      message: `Scope: initial_value "${val.initial_value}" must exist in options`
    })
  ),
  check_ticket: import_zod2.z.object({
    infer_ticket: import_zod2.z.boolean().default(true),
    confirm_ticket: import_zod2.z.boolean().default(true),
    add_to_title: import_zod2.z.boolean().default(true),
    append_hashtag: import_zod2.z.boolean().default(false),
    surround: import_zod2.z.enum(["", "()", "[]", "{}"]).default(""),
    title_position: import_zod2.z.enum(["start", "end", "before-colon"]).default("start")
  }).default({}),
  commit_title: import_zod2.z.object({
    max_size: import_zod2.z.number().positive().default(70)
  }).default({}),
  commit_body: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    required: import_zod2.z.boolean().default(false)
  }).default({}),
  commit_footer: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    initial_value: import_zod2.z.array(Z_FOOTER_OPTIONS).default([]),
    options: import_zod2.z.array(Z_FOOTER_OPTIONS).default(FOOTER_OPTION_VALUES)
  }).default({}),
  breaking_change: import_zod2.z.object({
    add_exclamation_to_title: import_zod2.z.boolean().default(true)
  }).default({}),
  confirm_commit: import_zod2.z.boolean().default(true),
  print_commit_output: import_zod2.z.boolean().default(true),
  branch_pre_commands: import_zod2.z.array(import_zod2.z.string()).default([]),
  branch_post_commands: import_zod2.z.array(import_zod2.z.string()).default([]),
  worktree_pre_commands: import_zod2.z.array(import_zod2.z.string()).default([]),
  worktree_post_commands: import_zod2.z.array(import_zod2.z.string()).default([]),
  branch_user: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    required: import_zod2.z.boolean().default(false),
    separator: import_zod2.z.enum(["/", "-", "_"]).default("/")
  }).default({}),
  branch_type: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    separator: import_zod2.z.enum(["/", "-", "_"]).default("/")
  }).default({}),
  branch_version: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(false),
    required: import_zod2.z.boolean().default(false),
    separator: import_zod2.z.enum(["/", "-", "_"]).default("/")
  }).default({}),
  branch_ticket: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    required: import_zod2.z.boolean().default(false),
    separator: import_zod2.z.enum(["/", "-", "_"]).default("-")
  }).default({}),
  branch_description: import_zod2.z.object({
    max_length: import_zod2.z.number().positive().default(70),
    separator: import_zod2.z.enum(["", "/", "-", "_"]).default("")
  }).default({}),
  branch_action_default: Z_BRANCH_ACTIONS.default("branch"),
  branch_order: import_zod2.z.array(Z_BRANCH_FIELDS).default(BRANCH_ORDER_DEFAULTS),
  enable_worktrees: import_zod2.z.boolean().default(true),
  overrides: import_zod2.z.object({ shell: import_zod2.z.string().optional() }).default({})
}).default({});
var CommitState = import_zod2.z.object({
  type: import_zod2.z.string().default(""),
  scope: import_zod2.z.string().default(""),
  title: import_zod2.z.string().default(""),
  body: import_zod2.z.string().default(""),
  closes: import_zod2.z.string().default(""),
  ticket: import_zod2.z.string().default(""),
  breaking_title: import_zod2.z.string().default(""),
  breaking_body: import_zod2.z.string().default(""),
  deprecates: import_zod2.z.string().default(""),
  deprecates_title: import_zod2.z.string().default(""),
  deprecates_body: import_zod2.z.string().default(""),
  custom_footer: import_zod2.z.string().default(""),
  trailer: import_zod2.z.string().default("")
}).default({});
var BranchState = import_zod2.z.object({
  user: import_zod2.z.string().default(""),
  type: import_zod2.z.string().default(""),
  ticket: import_zod2.z.string().default(""),
  description: import_zod2.z.string().default(""),
  version: import_zod2.z.string().default("")
}).default({});

// src/branch.ts
var p2 = __toESM(require("@clack/prompts"));
var import_configstore = __toESM(require("configstore"));
var import_child_process2 = require("child_process");
var import_picocolors2 = __toESM(require("picocolors"));
var import_process = require("process");
main(load_setup(" better-branch "));
async function main(config) {
  const branch_state = BranchState.parse({});
  let checkout_type = "branch";
  if (config.enable_worktrees) {
    const branch_or_worktree = await p2.select({
      message: `Checkout a branch or create a worktree?`,
      initialValue: config.branch_action_default,
      options: BRANCH_ACTION_OPTIONS
    });
    if (p2.isCancel(branch_or_worktree))
      process.exit();
    checkout_type = branch_or_worktree;
  }
  if (config.branch_user.enable) {
    const cache_user_name = get_user_from_cache();
    const user_name_required = config.branch_user.required;
    const user_name = await p2.text({
      message: `Type your git username ${user_name_required ? "" : OPTIONAL_PROMPT} ${CACHE_PROMPT}`.trim(),
      placeholder: "",
      initialValue: cache_user_name,
      validate: (val) => {
        if (user_name_required && !val)
          return "Please enter a username";
      }
    });
    if (p2.isCancel(user_name))
      process.exit(0);
    branch_state.user = user_name?.replace(/\s+/g, "-")?.toLowerCase() ?? "";
    set_user_cache(branch_state.user);
  }
  if (config.branch_type.enable) {
    let initial_value = config.commit_type.initial_value;
    const commit_type = await p2.select({
      message: `Select a branch type`,
      initialValue: initial_value,
      options: config.commit_type.options
    });
    if (p2.isCancel(commit_type))
      process.exit(0);
    branch_state.type = commit_type;
  }
  if (config.branch_ticket.enable) {
    const ticked_required = config.branch_ticket.required;
    const ticket = await p2.text({
      message: `Type ticket / issue number ${ticked_required ? "" : OPTIONAL_PROMPT}`.trim(),
      placeholder: "",
      validate: (val) => {
        if (ticked_required && !val)
          return "Please enter a ticket / issue";
      }
    });
    if (p2.isCancel(ticket))
      process.exit(0);
    branch_state.ticket = ticket;
  }
  if (config.branch_version.enable) {
    const version_required = config.branch_version.required;
    const version = await p2.text({
      message: `Type version number ${version_required ? "" : OPTIONAL_PROMPT}`.trim(),
      placeholder: "",
      validate: (val) => {
        if (version_required && !val)
          return "Please enter a version";
      }
    });
    if (p2.isCancel(version))
      process.exit(0);
    branch_state.version = version;
  }
  const description_max_length = config.branch_description.max_length;
  const description = await p2.text({
    message: "Type a short description",
    placeholder: "",
    validate: (value) => {
      if (!value)
        return "Please enter a description";
      if (value.length > description_max_length)
        return `Exceeded max length. Description max [${description_max_length}]`;
    }
  });
  if (p2.isCancel(description))
    process.exit(0);
  branch_state.description = description?.replace(/\s+/g, "-")?.toLowerCase() ?? "";
  const pre_commands = checkout_type === "worktree" ? config.worktree_pre_commands : config.branch_pre_commands;
  pre_commands.forEach((command) => {
    try {
      (0, import_child_process2.execSync)(command, { stdio: "inherit" });
    } catch (err) {
      p2.log.error("Something went wrong when executing pre-commands: " + err);
      process.exit(0);
    }
  });
  const branch_name = build_branch(branch_state, config);
  const branch_flag = verify_branch_name(branch_name);
  if (checkout_type === "branch") {
    try {
      (0, import_child_process2.execSync)(`git checkout ${branch_flag} ${branch_name}`, {
        stdio: "inherit"
      });
      p2.log.info(
        `Switched to a new branch '${import_picocolors2.default.bgGreen(
          " " + import_picocolors2.default.black(branch_name) + " "
        )}'`
      );
    } catch (err) {
      process.exit(0);
    }
  } else {
    try {
      const ticket = branch_state.ticket ? `${branch_state.ticket}-` : "";
      const worktree_name = `${ticket}${branch_state.description}`;
      (0, import_child_process2.execSync)(
        `git worktree add ${worktree_name} ${branch_flag} ${branch_name}`,
        {
          stdio: "inherit"
        }
      );
      p2.log.info(
        `Created a new worktree ${import_picocolors2.default.bgGreen(
          +" " + import_picocolors2.default.black(worktree_name) + " "
        )}, checked out branch ${import_picocolors2.default.bgGreen(
          " " + import_picocolors2.default.black(branch_name) + " "
        )}`
      );
      p2.log.info(
        import_picocolors2.default.bgMagenta(import_picocolors2.default.black(` cd ${worktree_name} `)) + " to navigate to your new worktree"
      );
      (0, import_process.chdir)(worktree_name);
    } catch (err) {
      process.exit(0);
    }
  }
  const post_commands = checkout_type === "worktree" ? config.worktree_post_commands : config.branch_post_commands;
  post_commands.forEach((command) => {
    try {
      (0, import_child_process2.execSync)(command, { stdio: "inherit" });
    } catch (err) {
      p2.log.error("Something went wrong when executing post-commands: " + err);
      process.exit(0);
    }
  });
}
function build_branch(branch, config) {
  let res = "";
  config.branch_order.forEach((b) => {
    const config_key = `branch_${b}`;
    if (branch[b])
      res += branch[b] + config[config_key].separator;
  });
  if (res.endsWith("-") || res.endsWith("/") || res.endsWith("_")) {
    return res.slice(0, -1).trim();
  }
  return res.trim();
}
function get_user_from_cache() {
  try {
    const config_store = new import_configstore.default("better-commits");
    return config_store.get("username") ?? "";
  } catch (err) {
    p2.log.warn(
      'There was an issue accessing username from cache. Check that the folder "~/.config" exists'
    );
  }
  return "";
}
function verify_branch_name(branch_name) {
  let branch_flag = "";
  try {
    (0, import_child_process2.execSync)(`git show-ref ${branch_name}`, { encoding: "utf-8" });
    p2.log.warning(
      import_picocolors2.default.yellow(
        `${branch_name} already exists! Checking out existing branch.`
      )
    );
  } catch (err) {
    branch_flag = "-b";
  }
  return branch_flag;
}
function set_user_cache(val) {
  try {
    const config_store = new import_configstore.default("better-commits");
    config_store.set("username", val);
  } catch (err) {
  }
}
