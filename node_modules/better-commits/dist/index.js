#! /usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  main: () => main
});
module.exports = __toCommonJS(src_exports);
var p3 = __toESM(require("@clack/prompts"));
var import_picocolors3 = __toESM(require("picocolors"));
var import_child_process3 = require("child_process");
var import_process = require("process");

// src/zod-state.ts
var import_zod2 = require("zod");

// src/utils.ts
var import_os = require("os");
var import_zod = require("zod");
var import_picocolors = __toESM(require("picocolors"));
var import_child_process = require("child_process");
var p = __toESM(require("@clack/prompts"));
var import_fs = __toESM(require("fs"));
var import_zod_validation_error = require("zod-validation-error");
var CONFIG_FILE_NAME = ".better-commits.json";
var SPACE_TO_SELECT = `${import_picocolors.default.dim("(<space> to select)")}`;
var A_FOR_ALL = `${import_picocolors.default.dim(
  "(<space> to select, <a> to select all)"
)}`;
var OPTIONAL_PROMPT = `${import_picocolors.default.dim("(optional)")}`;
var CACHE_PROMPT = `${import_picocolors.default.dim("(value will be saved)")}`;
var REGEX_SLASH_TAG = new RegExp(/\/(\w+-\d+)/);
var REGEX_START_TAG = new RegExp(/^(\w+-\d+)/);
var REGEX_START_UND = new RegExp(/^([A-Z]+-[\[a-zA-Z\]\d]+)_/);
var REGEX_SLASH_UND = new RegExp(/\/([A-Z]+-[\[a-zA-Z\]\d]+)_/);
var REGEX_SLASH_NUM = new RegExp(/\/(\d+)/);
var REGEX_START_NUM = new RegExp(/^(\d+)/);
var DEFAULT_TYPE_OPTIONS = [
  { value: "feat", label: "feat", hint: "A new feature", emoji: "\u2728", trailer: "Changelog: feature" },
  { value: "fix", label: "fix", hint: "A bug fix", emoji: "\u{1F41B}", trailer: "Changelog: fix" },
  {
    value: "docs",
    label: "docs",
    hint: "Documentation only changes",
    emoji: "\u{1F4DA}",
    trailer: "Changelog: documentation"
  },
  {
    value: "refactor",
    label: "refactor",
    hint: "A code change that neither fixes a bug nor adds a feature",
    emoji: "\u{1F528}",
    trailer: "Changelog: refactor"
  },
  {
    value: "perf",
    label: "perf",
    hint: "A code change that improves performance",
    emoji: "\u{1F680}",
    trailer: "Changelog: performance"
  },
  {
    value: "test",
    label: "test",
    hint: "Adding missing tests or correcting existing tests",
    emoji: "\u{1F6A8}",
    trailer: "Changelog: test"
  },
  {
    value: "build",
    label: "build",
    hint: "Changes that affect the build system or external dependencies",
    emoji: "\u{1F6A7}",
    trailer: "Changelog: build"
  },
  {
    value: "ci",
    label: "ci",
    hint: "Changes to our CI configuration files and scripts",
    emoji: "\u{1F916}",
    trailer: "Changelog: ci"
  },
  {
    value: "chore",
    label: "chore",
    hint: "Other changes that do not modify src or test files",
    emoji: "\u{1F9F9}",
    trailer: "Changelog: chore"
  },
  { value: "", label: "none" }
];
var DEFAULT_SCOPE_OPTIONS = [
  { value: "app", label: "app" },
  { value: "shared", label: "shared" },
  { value: "server", label: "server" },
  { value: "tools", label: "tools" },
  { value: "", label: "none" }
];
var COMMIT_FOOTER_OPTIONS = [
  {
    value: "closes",
    label: "closes <issue/ticket>",
    hint: "Attempts to infer ticket from branch"
  },
  {
    value: "trailer",
    label: "trailer",
    hint: "Appends trailer based on commit type"
  },
  {
    value: "breaking-change",
    label: "breaking change",
    hint: "Add breaking change"
  },
  { value: "deprecated", label: "deprecated", hint: "Add deprecated change" },
  { value: "custom", label: "custom", hint: "Add a custom footer" }
];
var CUSTOM_SCOPE_KEY = "custom";
var Z_FOOTER_OPTIONS = import_zod.z.enum([
  "closes",
  "trailer",
  "breaking-change",
  "deprecated",
  "custom"
]);
var Z_BRANCH_FIELDS = import_zod.z.enum(["user", "version", "type", "ticket", "description"]);
var Z_BRANCH_CONFIG_FIELDS = import_zod.z.enum([
  "branch_user",
  "branch_version",
  "branch_type",
  "branch_ticket",
  "branch_description"
]);
var BRANCH_ORDER_DEFAULTS = ["user", "version", "type", "ticket", "description"];
var Z_BRANCH_ACTIONS = import_zod.z.enum(["branch", "worktree"]);
var FOOTER_OPTION_VALUES = [
  "closes",
  "trailer",
  "breaking-change",
  "deprecated",
  "custom"
];
function load_setup(cli_name = " better-commits ") {
  console.clear();
  p.intro(`${import_picocolors.default.bgCyan(import_picocolors.default.black(cli_name))}`);
  const root = get_git_root();
  const root_path = `${root}/${CONFIG_FILE_NAME}`;
  if (import_fs.default.existsSync(root_path)) {
    p.log.step("Found repository config");
    return read_config_from_path(root_path);
  }
  const home_path = get_default_config_path();
  if (import_fs.default.existsSync(home_path)) {
    p.log.step("Found global config");
    return read_config_from_path(home_path);
  }
  const default_config = Config.parse({});
  p.log.step(
    "Config not found. Generating default .better-commit.json at $HOME"
  );
  import_fs.default.writeFileSync(home_path, JSON.stringify(default_config, null, 4));
  return default_config;
}
function read_config_from_path(config_path) {
  let res = null;
  try {
    res = JSON.parse(import_fs.default.readFileSync(config_path, "utf8"));
  } catch (err) {
    p.log.error("Invalid JSON file. Exiting.\n" + err);
    process.exit(0);
  }
  return validate_config(res);
}
function validate_config(config) {
  try {
    return Config.parse(config);
  } catch (err) {
    console.log((0, import_zod_validation_error.fromZodError)(err).message);
    process.exit(0);
  }
}
function infer_type_from_branch(types) {
  let branch = "";
  try {
    branch = (0, import_child_process.execSync)("git branch --show-current", {
      stdio: "pipe"
    }).toString();
  } catch (err) {
    return "";
  }
  const found = types.find((t) => {
    const start_dash = new RegExp(`^${t}-`);
    const between_dash = new RegExp(`-${t}-`);
    const before_slash = new RegExp(`${t}/`);
    const re = [
      branch.match(start_dash),
      branch.match(between_dash),
      branch.match(before_slash)
    ].filter((v) => v != null);
    return re?.length;
  });
  return found ?? "";
}
function get_git_root() {
  let path = ".";
  try {
    path = (0, import_child_process.execSync)("git rev-parse --show-toplevel").toString().trim();
  } catch (err) {
    p.log.warn(
      "Could not find git root. If in a --bare repository, ignore this warning."
    );
  }
  return path;
}
function get_default_config_path() {
  return (0, import_os.homedir)() + "/" + CONFIG_FILE_NAME;
}
function addNewLine(arr, i) {
  return i === arr.length - 1 ? "" : "\n";
}
function clean_commit_title(title) {
  const title_trimmed = title.trim();
  const remove_period = title_trimmed.endsWith(".");
  if (remove_period) {
    return title_trimmed.substring(0, title_trimmed.length - 1).trim();
  }
  return title.trim();
}

// src/zod-state.ts
var Config = import_zod2.z.object({
  check_status: import_zod2.z.boolean().default(true),
  commit_type: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    initial_value: import_zod2.z.string().default("feat"),
    infer_type_from_branch: import_zod2.z.boolean().default(true),
    append_emoji_to_label: import_zod2.z.boolean().default(false),
    append_emoji_to_commit: import_zod2.z.boolean().default(false),
    options: import_zod2.z.array(
      import_zod2.z.object({
        value: import_zod2.z.string(),
        label: import_zod2.z.string().optional(),
        hint: import_zod2.z.string().optional(),
        emoji: import_zod2.z.string().emoji().optional(),
        trailer: import_zod2.z.string().optional()
      })
    ).default(DEFAULT_TYPE_OPTIONS)
  }).default({}).transform((val) => {
    const options = val.options.map((v) => ({
      ...v,
      label: v.emoji && val.append_emoji_to_label ? `${v.emoji} ${v.label}` : v.label
    }));
    return { ...val, options };
  }).refine(
    (val) => val.options.map((v) => v.value).includes(val.initial_value),
    (val) => ({
      message: `Type: initial_value "${val.initial_value}" must exist in options`
    })
  ),
  commit_scope: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    custom_scope: import_zod2.z.boolean().default(false),
    initial_value: import_zod2.z.string().default("app"),
    options: import_zod2.z.array(
      import_zod2.z.object({
        value: import_zod2.z.string(),
        label: import_zod2.z.string().optional(),
        hint: import_zod2.z.string().optional()
      })
    ).default(DEFAULT_SCOPE_OPTIONS)
  }).default({}).transform((val) => {
    const options = val.options.map((v) => v.value);
    if (val.custom_scope && !options.includes(CUSTOM_SCOPE_KEY)) {
      return {
        ...val,
        options: [
          ...val.options,
          {
            label: CUSTOM_SCOPE_KEY,
            value: CUSTOM_SCOPE_KEY,
            hint: "Write a custom scope"
          }
        ]
      };
    }
    return val;
  }).refine(
    (val) => {
      const options = val.options.map((v) => v.value);
      return options.includes(val.initial_value);
    },
    (val) => ({
      message: `Scope: initial_value "${val.initial_value}" must exist in options`
    })
  ),
  check_ticket: import_zod2.z.object({
    infer_ticket: import_zod2.z.boolean().default(true),
    confirm_ticket: import_zod2.z.boolean().default(true),
    add_to_title: import_zod2.z.boolean().default(true),
    append_hashtag: import_zod2.z.boolean().default(false),
    surround: import_zod2.z.enum(["", "()", "[]", "{}"]).default(""),
    title_position: import_zod2.z.enum(["start", "end", "before-colon"]).default("start")
  }).default({}),
  commit_title: import_zod2.z.object({
    max_size: import_zod2.z.number().positive().default(70)
  }).default({}),
  commit_body: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    required: import_zod2.z.boolean().default(false)
  }).default({}),
  commit_footer: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    initial_value: import_zod2.z.array(Z_FOOTER_OPTIONS).default([]),
    options: import_zod2.z.array(Z_FOOTER_OPTIONS).default(FOOTER_OPTION_VALUES)
  }).default({}),
  breaking_change: import_zod2.z.object({
    add_exclamation_to_title: import_zod2.z.boolean().default(true)
  }).default({}),
  confirm_commit: import_zod2.z.boolean().default(true),
  print_commit_output: import_zod2.z.boolean().default(true),
  branch_pre_commands: import_zod2.z.array(import_zod2.z.string()).default([]),
  branch_post_commands: import_zod2.z.array(import_zod2.z.string()).default([]),
  worktree_pre_commands: import_zod2.z.array(import_zod2.z.string()).default([]),
  worktree_post_commands: import_zod2.z.array(import_zod2.z.string()).default([]),
  branch_user: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    required: import_zod2.z.boolean().default(false),
    separator: import_zod2.z.enum(["/", "-", "_"]).default("/")
  }).default({}),
  branch_type: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    separator: import_zod2.z.enum(["/", "-", "_"]).default("/")
  }).default({}),
  branch_version: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(false),
    required: import_zod2.z.boolean().default(false),
    separator: import_zod2.z.enum(["/", "-", "_"]).default("/")
  }).default({}),
  branch_ticket: import_zod2.z.object({
    enable: import_zod2.z.boolean().default(true),
    required: import_zod2.z.boolean().default(false),
    separator: import_zod2.z.enum(["/", "-", "_"]).default("-")
  }).default({}),
  branch_description: import_zod2.z.object({
    max_length: import_zod2.z.number().positive().default(70),
    separator: import_zod2.z.enum(["", "/", "-", "_"]).default("")
  }).default({}),
  branch_action_default: Z_BRANCH_ACTIONS.default("branch"),
  branch_order: import_zod2.z.array(Z_BRANCH_FIELDS).default(BRANCH_ORDER_DEFAULTS),
  enable_worktrees: import_zod2.z.boolean().default(true),
  overrides: import_zod2.z.object({ shell: import_zod2.z.string().optional() }).default({})
}).default({});
var CommitState = import_zod2.z.object({
  type: import_zod2.z.string().default(""),
  scope: import_zod2.z.string().default(""),
  title: import_zod2.z.string().default(""),
  body: import_zod2.z.string().default(""),
  closes: import_zod2.z.string().default(""),
  ticket: import_zod2.z.string().default(""),
  breaking_title: import_zod2.z.string().default(""),
  breaking_body: import_zod2.z.string().default(""),
  deprecates: import_zod2.z.string().default(""),
  deprecates_title: import_zod2.z.string().default(""),
  deprecates_body: import_zod2.z.string().default(""),
  custom_footer: import_zod2.z.string().default(""),
  trailer: import_zod2.z.string().default("")
}).default({});
var BranchState = import_zod2.z.object({
  user: import_zod2.z.string().default(""),
  type: import_zod2.z.string().default(""),
  ticket: import_zod2.z.string().default(""),
  description: import_zod2.z.string().default(""),
  version: import_zod2.z.string().default("")
}).default({});

// src/git.ts
var import_child_process2 = require("child_process");
var p2 = __toESM(require("@clack/prompts"));
var import_picocolors2 = __toESM(require("picocolors"));
var porcelain_states = ["M", "T", "R", "D", "A", "C"];
function git_status() {
  let status = "";
  try {
    status = (0, import_child_process2.execSync)("git status --porcelain", { stdio: "pipe" }).toString();
  } catch (err) {
    p2.log.error(import_picocolors2.default.red("Failed to git status"));
    return { index: [], work_tree: [] };
  }
  const lines = status.split("\n");
  const work_tree = [];
  const index = [];
  lines.forEach((v) => {
    const line = v.trimEnd();
    if (!line)
      return;
    const path_plus_file = line.substring(2).trim();
    const first_char = line.charAt(0).trim();
    const second_char = line.charAt(1).trim();
    if (first_char === "?" || second_char === "?") {
      work_tree.push(path_plus_file);
    }
    if (porcelain_states.includes(first_char)) {
      index.push(path_plus_file);
    }
    if (porcelain_states.includes(second_char)) {
      work_tree.push(path_plus_file);
    }
  });
  return { index, work_tree };
}
function git_add(files) {
  const space_delimited_files = files.join(" ");
  if (space_delimited_files) {
    try {
      (0, import_child_process2.execSync)(`git add ${space_delimited_files}`, {
        stdio: "pipe"
      }).toString();
      p2.log.success(import_picocolors2.default.green("Changes successfully staged"));
    } catch (err) {
      p2.log.error(import_picocolors2.default.red("Failed to stage changes"));
    }
  }
}

// src/index.ts
main(load_setup());
async function main(config) {
  let commit_state = CommitState.parse({});
  (0, import_process.chdir)(get_git_root());
  if (config.check_status) {
    let { index, work_tree } = git_status();
    p3.log.step(import_picocolors3.default.black(import_picocolors3.default.bgGreen(" Checking Git Status ")));
    const staged_files = index.reduce((acc, curr, i) => import_picocolors3.default.green(acc + curr + addNewLine(index, i)), "");
    p3.log.success("Changes to be committed:\n" + staged_files);
    if (work_tree.length) {
      const unstaged_files = work_tree.reduce((acc, curr, i) => import_picocolors3.default.red(acc + curr + addNewLine(work_tree, i)), "");
      p3.log.error("Changes not staged for commit:\n" + unstaged_files);
      const selected_for_staging = await p3.multiselect({
        message: `Some files have not been staged, would you like to add them now? ${SPACE_TO_SELECT}`,
        options: [{ value: ".", label: "." }, ...work_tree.map((v) => ({ value: v, label: v }))],
        required: false
      });
      if (p3.isCancel(selected_for_staging))
        process.exit(0);
      git_add(selected_for_staging);
    }
    let updated_status = git_status();
    if (!updated_status.index.length) {
      p3.log.error(import_picocolors3.default.red('no changes added to commit (use "git add" and/or "git commit -a")'));
      process.exit(0);
    }
  }
  if (config.commit_type.enable) {
    let message = "Select a commit type";
    let initial_value = config.commit_type.initial_value;
    if (config.commit_type.infer_type_from_branch) {
      const options = config.commit_type.options.map((o) => o.value);
      const type_from_branch = infer_type_from_branch(options);
      if (type_from_branch) {
        message = `Commit type inferred from branch ${import_picocolors3.default.dim("(confirm / edit)")}`;
        initial_value = type_from_branch;
      }
    }
    const value_to_data = config.commit_type.options.reduce(
      (acc, curr) => ({ ...acc, [curr.value]: { emoji: curr.emoji ?? "", trailer: curr.trailer ?? "" } }),
      {}
    );
    const commit_type = await p3.select(
      {
        message,
        initialValue: initial_value,
        options: config.commit_type.options
      }
    );
    if (p3.isCancel(commit_type))
      process.exit(0);
    commit_state.trailer = value_to_data[commit_type].trailer;
    commit_state.type = config.commit_type.append_emoji_to_commit ? `${value_to_data[commit_type].emoji} ${commit_type}`.trim() : commit_type;
  }
  if (config.commit_scope.enable) {
    let commit_scope = await p3.select({
      message: "Select a commit scope",
      initialValue: config.commit_scope.initial_value,
      options: config.commit_scope.options
    });
    if (p3.isCancel(commit_scope))
      process.exit(0);
    if (commit_scope === CUSTOM_SCOPE_KEY && config.commit_scope.custom_scope) {
      commit_scope = await p3.text({
        message: "Write a custom scope",
        placeholder: ""
      });
      if (p3.isCancel(commit_scope))
        process.exit(0);
    }
    commit_state.scope = commit_scope;
  }
  if (config.check_ticket.infer_ticket) {
    try {
      const branch = (0, import_child_process3.execSync)("git branch --show-current", { stdio: "pipe" }).toString();
      const found = [
        branch.match(REGEX_START_UND),
        branch.match(REGEX_SLASH_UND),
        branch.match(REGEX_SLASH_TAG),
        branch.match(REGEX_SLASH_NUM),
        branch.match(REGEX_START_TAG),
        branch.match(REGEX_START_NUM)
      ].filter((v) => v != null).map((v) => v && v.length >= 2 ? v[1] : "");
      if (found.length && found[0]) {
        commit_state.ticket = config.check_ticket.append_hashtag ? "#" + found[0] : found[0];
      }
    } catch (err) {
    }
  }
  if (config.check_ticket.confirm_ticket) {
    const user_commit_ticket = await p3.text({
      message: commit_state.ticket ? `Ticket / issue inferred from branch ${import_picocolors3.default.dim("(confirm / edit)")}` : `Add ticket / issue ${OPTIONAL_PROMPT}`,
      placeholder: "",
      initialValue: commit_state.ticket
    });
    if (p3.isCancel(user_commit_ticket))
      process.exit(0);
    commit_state.ticket = user_commit_ticket ?? "";
  }
  const commit_title = await p3.text(
    {
      message: "Write a brief title describing the commit",
      placeholder: "",
      validate: (value) => {
        if (!value)
          return "Please enter a title";
        const commit_scope_size = commit_state.scope ? commit_state.scope.length + 2 : 0;
        const commit_type_size = commit_state.type.length;
        const commit_ticket_size = config.check_ticket.add_to_title ? commit_state.ticket.length : 0;
        if (commit_scope_size + commit_type_size + commit_ticket_size + value.length > config.commit_title.max_size)
          return `Exceeded max length. Title max [${config.commit_title.max_size}]`;
      }
    }
  );
  if (p3.isCancel(commit_title))
    process.exit(0);
  commit_state.title = clean_commit_title(commit_title);
  if (config.commit_body.enable) {
    const commit_body = await p3.text({
      message: `Write a detailed description of the changes ${OPTIONAL_PROMPT}`,
      placeholder: "",
      validate: (val) => {
        if (config.commit_body.required && !val)
          return "Please enter a description";
      }
    });
    if (p3.isCancel(commit_body))
      process.exit(0);
    commit_state.body = commit_body ?? "";
  }
  if (config.commit_footer.enable) {
    const commit_footer = await p3.multiselect({
      message: `Select optional footers ${SPACE_TO_SELECT}`,
      initialValues: config.commit_footer.initial_value,
      options: COMMIT_FOOTER_OPTIONS,
      required: false
    });
    if (p3.isCancel(commit_footer))
      process.exit(0);
    if (commit_footer.includes("breaking-change")) {
      const breaking_changes_title = await p3.text({
        message: "Breaking changes: Write a short title / summary",
        placeholder: "",
        validate: (value) => {
          if (!value)
            return "Please enter a title / summary";
        }
      });
      if (p3.isCancel(breaking_changes_title))
        process.exit(0);
      const breaking_changes_body = await p3.text({
        message: `Breaking Changes: Write a description & migration instructions ${OPTIONAL_PROMPT}`,
        placeholder: ""
      });
      if (p3.isCancel(breaking_changes_body))
        process.exit(0);
      commit_state.breaking_title = breaking_changes_title;
      commit_state.breaking_body = breaking_changes_body;
    }
    if (commit_footer.includes("deprecated")) {
      const deprecated_title = await p3.text({
        message: "Deprecated: Write a short title / summary",
        placeholder: "",
        validate: (value) => {
          if (!value)
            return "Please enter a title / summary";
        }
      });
      if (p3.isCancel(deprecated_title))
        process.exit(0);
      const deprecated_body = await p3.text({
        message: `Deprecated: Write a description ${OPTIONAL_PROMPT}`,
        placeholder: ""
      });
      if (p3.isCancel(deprecated_body))
        process.exit(0);
      commit_state.deprecates_body = deprecated_body;
      commit_state.deprecates_title = deprecated_title;
    }
    if (commit_footer.includes("closes")) {
      commit_state.closes = "Closes:";
    }
    if (commit_footer.includes("custom")) {
      const custom_footer = await p3.text({
        message: "Write a custom footer",
        placeholder: ""
      });
      if (p3.isCancel(custom_footer))
        process.exit(0);
      commit_state.custom_footer = custom_footer;
    }
    if (!commit_footer.includes("trailer")) {
      commit_state.trailer = "";
    }
  }
  let continue_commit = true;
  p3.note(build_commit_string(commit_state, config, true, false, true), "Commit Preview");
  if (config.confirm_commit) {
    continue_commit = await p3.confirm({ message: "Confirm Commit?" });
    if (p3.isCancel(continue_commit))
      process.exit(0);
  }
  if (!continue_commit) {
    p3.log.info("Exiting without commit");
    process.exit(0);
  }
  try {
    const options = config.overrides.shell ? { shell: config.overrides.shell } : {};
    const trailer = commit_state.trailer ? `--trailer="${commit_state.trailer}"` : "";
    const output = (0, import_child_process3.execSync)(`git commit -m "${build_commit_string(commit_state, config, false, true, false)}" ${trailer}`, options).toString().trim();
    if (config.print_commit_output)
      p3.log.info(output);
  } catch (err) {
    p3.log.error("Something went wrong when committing: " + err);
  }
}
function build_commit_string(commit_state, config, colorize = false, escape_quotes = false, include_trailer = false) {
  let commit_string = "";
  if (commit_state.type) {
    commit_string += colorize ? import_picocolors3.default.blue(commit_state.type) : commit_state.type;
  }
  if (commit_state.scope) {
    const scope = colorize ? import_picocolors3.default.cyan(commit_state.scope) : commit_state.scope;
    commit_string += `(${scope})`;
  }
  let title_ticket = commit_state.ticket;
  const surround = config.check_ticket.surround;
  if (commit_state.ticket && surround) {
    const open_token = surround.charAt(0);
    const close_token = surround.charAt(1);
    title_ticket = `${open_token}${commit_state.ticket}${close_token}`;
  }
  const position_before_colon = config.check_ticket.title_position === "before-colon";
  if (title_ticket && config.check_ticket.add_to_title && position_before_colon) {
    const spacing = commit_state.scope || commit_state.type && !config.check_ticket.surround ? " " : "";
    commit_string += colorize ? import_picocolors3.default.magenta(spacing + title_ticket) : spacing + title_ticket;
  }
  if (commit_state.breaking_title && config.breaking_change.add_exclamation_to_title) {
    commit_string += colorize ? import_picocolors3.default.red("!") : "!";
  }
  if (commit_state.scope || commit_state.type || title_ticket && position_before_colon) {
    commit_string += ": ";
  }
  const position_start = config.check_ticket.title_position === "start";
  const position_end = config.check_ticket.title_position === "end";
  if (title_ticket && config.check_ticket.add_to_title && position_start) {
    commit_string += colorize ? import_picocolors3.default.magenta(title_ticket) + " " : title_ticket + " ";
  }
  if (commit_state.title) {
    commit_string += colorize ? import_picocolors3.default.reset(commit_state.title) : commit_state.title;
  }
  if (title_ticket && config.check_ticket.add_to_title && position_end) {
    commit_string += " " + (colorize ? import_picocolors3.default.magenta(title_ticket) : title_ticket);
  }
  if (commit_state.body) {
    const temp = commit_state.body.split("\\n");
    const res = temp.map((v) => colorize ? import_picocolors3.default.reset(v.trim()) : v.trim()).join("\n");
    commit_string += colorize ? `

${res}` : `

${res}`;
  }
  if (commit_state.breaking_title) {
    const title = colorize ? import_picocolors3.default.red(`BREAKING CHANGE: ${commit_state.breaking_title}`) : `BREAKING CHANGE: ${commit_state.breaking_title}`;
    commit_string += `

${title}`;
  }
  if (commit_state.breaking_body) {
    const body = colorize ? import_picocolors3.default.red(commit_state.breaking_body) : commit_state.breaking_body;
    commit_string += `

${body}`;
  }
  if (commit_state.deprecates_title) {
    const title = colorize ? import_picocolors3.default.yellow(`DEPRECATED: ${commit_state.deprecates_title}`) : `DEPRECATED: ${commit_state.deprecates_title}`;
    commit_string += `

${title}`;
  }
  if (commit_state.deprecates_body) {
    const body = colorize ? import_picocolors3.default.yellow(commit_state.deprecates_body) : commit_state.deprecates_body;
    commit_string += `

${body}`;
  }
  if (commit_state.custom_footer) {
    const temp = commit_state.custom_footer.split("\\n");
    const res = temp.map((v) => colorize ? import_picocolors3.default.reset(v.trim()) : v.trim()).join("\n");
    commit_string += colorize ? `

${res}` : `

${res}`;
  }
  if (commit_state.closes && commit_state.ticket) {
    commit_string += colorize ? `

${import_picocolors3.default.reset(commit_state.closes)} ${import_picocolors3.default.magenta(commit_state.ticket)}` : `

${commit_state.closes} ${commit_state.ticket}`;
  }
  if (include_trailer && commit_state.trailer) {
    commit_string += colorize ? `

${import_picocolors3.default.dim(commit_state.trailer)}` : `

${commit_state.trailer}`;
  }
  if (escape_quotes) {
    commit_string = commit_string.replaceAll('"', '\\"');
  }
  return commit_string;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  main
});
